## 五层协议

数据传输过程概况：

1.主机进程在应用层发送数据形成**报文**，报文被运输层送到网络层包装成**IP数据报**，网络层也会选择合适的路由使得数据确定最终发送到的目的主机。

2.链路层把IP数据报添加控制信息封装成**帧**，通过链路发送给另一台主机。

3.数据传输过程是在物理层上的**比特流**传输。

### 应用层

应用层协议定义的是主机应用**进程间**的通信和交互的规则

应用层协议包括**域名系统 DNS**，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**

我们把应用层交互的数据单元称为**报文**。

### 运输层

运输层负责**两台主机进程之间**的通信提供**通用的**数据传输服务。应用进程利用该服务传输应用层报文。通用的是指多种应用可以使用同一个运输层服务。

运输层有TCP和UDP两种协议：

#### 传输控制协议 TCP（Transmisson Control Protocol）

1.提供**面向连接**的，**可靠的**数据传输服务。

> 连接：就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接。TCP的连接要进行三次握手，断开连接要进行四次挥手

2.TCP面向字节流（把上面应用层交下来的数据看成无结构的字节流来发送）

3.TCP是点对点

4.TCP是全双工通信

> 全双工：允许通信双方的应用进程在任何时候都能发送数据

5.传输效率较低

#### 用户数据协议 UDP（User Datagram Protocol）

1.提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

2.UDP面向报文

3.UDP 支持一对一、一对多、多对一和多对多的交互通信

4.传输效率较高

### 网络层

1.把运输层产生的报文段或用户数据报**封装成分组和包**进行传送。

在TCP/IP体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

2.网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机

> 这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。

### 数据链路层

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议

在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装程帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

接收端接收到数据之后，通过数据中的控制信息知道帧从哪个bit开始，哪个bit结束。如果发现差错，要进行丢弃或纠错。

### 物理层

 物理层(physical layer)的作用是**实现相邻计算机节点之间比特流的透明传送**，尽可能屏蔽掉具体传输介质和物理设备的差异（使其上面的数据链路层不必考虑网络的具体传输介质是什么）。在物理层上所传送的数据单位是**比特**。

## TCP 三次握手和四次挥手

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

![](./md-img/1633e14233d95972~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

三次握手的原因：发送方和接收方各自确认自己和对方的发送与接收正常



![](./md-img/1633e1676e2ac0a3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送

服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号

服务器-关闭与客户端的连接，发送一个FIN给客户端

客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

四次挥手的原因：

任何一方在数据传输结束后发出释放连接通知，待对方确认后进入半关闭状态。此时另一方还可以传输数据。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

## 状态码

状态码第一位数字决定了不同的响应状态，有如下：

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

## DNS

域名系统，进行域名与之相对应的IP地址的转换

...（后续略）

## CDN

略

## HTTP1.0/1.1/2.0/3.0 的区别

### HTTP1.0

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

### HTTP1.1

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是**按次序进行的**，服务器只有处理完一个请求，才会接着处理下一个请求。**如果前面的处理特别慢**，后面就会有许多请求排队等着(对头阻塞)
- 新增了一些请求方法
- 新增了一些请求头和响应头
### HTTP2.0

- 采用二进制格式而非文本格式

- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现多条流**并行**(在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应,而且不用按照顺序一一对应，这样就避免了”队头堵塞”)

- 使用报头压缩，降低开销

- 服务器推送

>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

### HTTP3.0（了解）

- HTTP3.0使用了QUIC协议

  QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议

  QUIC原生实现了多路复用，可以保证一个TCP中多个数据流有序交付且不影响其他的数据流（具体实现存疑，后续可以查看参考2），解决只用一个TCP连接时发生丢包导致整个TCP所有数据流都要重传的问题。

## HTTPS

### 定义

HTTPS=HTTP+TLS/SSL

HTTP存在问题：

- 通信使用明文（不加密），内容可能被窃听
- 不验证通信方的身份，因此有可能遭遇伪装

### SSL

SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议

- 对称加密：采用协商的密钥对数据加密

- 非对称加密：实现身份认证和密钥协商

#### 混合加密

SSL使用了混合加密，即对称加密+非对称加密。使用非对称加密一个对称密钥之后安全交换该密钥，双方传输数据时需要使用这个对称密钥

![](./md-img/bVbClUi.png)

  步骤：

  1.服务端拥有公钥和私钥，并散发公钥。客户端得到公钥，并生成一个对称密钥key用于之后加密和解密本次传输的数据。

  2.客户端使用公钥加密对称密钥key，发送给服务端，服务端使用私钥解密获得对称密钥key

  3.双方使用对称密钥进行数据的加密传输

#### 摘要算法：验证信息的完整性

加密数据之后，还要保证数据的完整性，使用摘要算法实现

摘要算法包括散列函数、哈希函数。可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹

客户端在原文之后加一个生成的SHA-2的摘要。服务端收到后也计算一下消息的摘要，然后进行对比，如果一直就表示消息是完整的

#### 数字签名：身份验证

验证消息确实是从当前的客户端发送出来的

发送方持有自己的私钥，散发公钥，接收方获取公钥

发送方使用私钥对当前发送数据的摘要进行加密形成数字签名，接收方获取数据（原文+摘要+签名）后使用公钥解密签名，和摘要进行比较，如果一致就表示签名确实是发送方用自己的私钥加密摘要得到的，说明来自当前的发送方。

然后再对摘要进行计算获取新摘要对比数据中的原有摘要验证完整性。

#### CA验证机构

确保公开的公钥确实是来自服务端

## Web安全

待补充

参考：

https://juejin.cn/post/6844903662838349838#heading-31

https://mp.weixin.qq.com/s/wrOXO5MH4wtbuvrCPCQNQA

https://segmentfault.com/a/1190000021494676
