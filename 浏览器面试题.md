## 浏览器输入 URL 后发生了什么？

1.浏览器（应用层）DNS解析

2.根据解析出的`ip地址+端口`，浏览器（应用层）发起Http请求，请求中携带请求头请求体，并将大块数据分割成HTTP报文段，这就是发送请求报文。

3.传输层tcp协议三次握手保证传输过程的安全可靠。

4.网络层通过APR协议寻址得到接收方的Mac地址，IP协议把报文包装成IP数据报(分组和包)传送给接收方。

5.数据到达数据链路层添加控制信息封装成帧，发送给目的主机，请求阶段完成。



6.请求方在数据链路层收到数据包，层层传递到应用层，接收方应用进程获得这些请求报文。

7.收到了发送方的HTTP请求报文之后，进行请求的文件资源（如HTML页面）的寻找并给请求方发送响应报文（响应头、响应体）。



8.发送方收到响应报文后，如果报文中请求体的状态码表示请求成功，则接受返回的资源（如HTML页面），进行页面渲染。

参考：

[一篇文章搞定前端面试面试过前端的老铁都知道，对于前端，面试官喜欢一开始先问些HTML5新增元素啊特性啊，或者是js闭包啊 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903687593148429#heading-5)

[计算机网络的七层结构、五层结构和四层结构-云社区-华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/243504)

## 跨域

### 定义

协议、域名、ip、端口其中有一个不同就是跨域，ajax请求会失败

### 目的

跨域的目的是防止**CSRF攻击**。简单点说，CSRF 攻击是攻击网站利用用户在受害网站的登录态发起恶意请求（指攻击网站希望利用用户登录状态发送的请求）。

跨域还是发出了请求，并且服务器响应了，但是浏览器由于请求跨域拦截了响应，这样就阻止了CSRF攻击。

但是请求还是发出去了，所以并不能完全阻止CSRF（无法获取请求返回的数据，但可以发请求进行其他修改。比如表单发送POST跨域请求，表单无需获取返回数据，只要能发送请求数据即可，这样请求虽然跨域但还是成功进行了操作，没有阻止CSRF）。

### 解决跨域的方法

CORS

服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

## 浏览器缓存策略

浏览器缓存策略：强缓存、协商缓存

### 强缓存

不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

有以下Http响应头，通过后端设定：

Expires：日期

Cache-Control：max-age=10（优先级比Expires高）

### 协商缓存

强制缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识决定并告诉浏览器是否使用浏览器本地缓存的过程。

如果资源没有改变，服务端会返回304，浏览器使用缓存的数据。如果过期了，就正常请求资源响应。

#### ETag和If-None-Match

1.首次请求资源，服务端返回一个etag响应头（服务端通过对数据进行签名得到）给浏览器，浏览器缓存etag和数据。

2.再次请求时，浏览器发送一个请求，请求头中设置If-None-Match：etag。

3.服务端将If-None-Match和自身的etag(数据签名结果应该一致)进行比较，如果相同，则服务端会返回304，浏览器使用缓存的数据；如果不同就正常请求数据后响应。

#### Last-Modified和If-Modified-Since

1.首次请求资源，服务端返回一个Last-Modified响应头给浏览器，浏览器缓存Last-Modified和数据。

2.再次请求时，浏览器发送一个请求，请求头中设置If-Modified-Since：Last-Modified。

3.服务端将If-Modified-Since和该数据的Last-Modified进行比较，如果大于等于，说明结果数据自上次请求后未发生变化，则服务端会返回304，浏览器使用缓存的数据；如果小于，说明数据自上次请求后发生了变化，就正常请求数据响应。