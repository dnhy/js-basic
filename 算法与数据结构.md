## 算法

1.通过策略跳过某些不需要的情况

双指针

2.模拟

3.换一种计算策略

前缀和

## 滑动窗口最大值

1 3 -1 -3  5  3 2 1

queue

3 2 1

res

3 3 5 5 5 3

- 单调队列:单调减的队列

每次push，都把当前队列最后一个元素和它的前面的比这个新的val小的去除掉，大的不动，然后再push进去

每次pop，如果之前已经pop过了，就不pop，说明这个元素比新的元素小，不可能在队头。如果是没pop的元素，需要pop，说明这个元素之前是比队列后面的元素大的才能幸存到最后，那必然在队头，所以判断和队头相等就pop。

队列的第一个元素就是最大的元素

- 主调函数

先往队列加k个元素，然后往后移动窗口（移动时新增和删除队列元素，保证队列是递减的）。

## 二叉树

### 种类

- 满二叉树

- 完全二叉树

- 二叉搜索树

  节点有顺序的树

- 平衡二叉搜索树

  所有左子树和右子树的高度差距不能大于1

### 存储

数组、链表

### 遍历方式

深度优先、广度优先

- 深度优先搜索是前序中序后序

- 广度优先搜索是层序遍历

前序：中左右

中序：左中右

后序：左右中

使用递归、迭代实现

## 二叉树遍历

### 递归遍历

略

### 迭代遍历

#### 前序和后序

push的时机：遍历访问的顺序和处理的顺序是一致的，先访问根节点，就先处理根节点（处理是指放入结果数组以及遍历子节点）

数据结构：

使用栈，栈中总是存放**待处理节点**（处理是指放入结果数组以及查找其左右节点）

判断条件：未遍历完时，栈中总是有节点

思路：

放入一个根节点

进入循环

出一个节点，遍历该节点的下一层，每一层从右往左添加到栈中

出的节点会先作为结果放入结果数组，然后用栈继续遍历下一层，实现中左右

如何保证中优先：每次循环都把中放入，再通过栈遍历下一层

对于后续遍历：

前序遍历：中左右

后续遍历：左右中

后续遍历只需要把前序遍历的代码更换左右位置，变成中右左，然后翻转结果数组，变成左右中即可

#### 中序遍历

左中右

push的时机：遍历和处理的顺序是不一样的，先遍历的先不处理（处理是指放入结果数组以及遍历子节点）

数据结构：

栈中放入**待处理的节点**（处理是指放入结果数组以及查找其左右节点）

思路：

​		     5
​	      /      \
​	   4	 	 6
​    /      \
 1	      2

如何保证左优先：每次循环先把左孩子放入结果数组中

退出循环的时机:指针指到null且栈为空

进行循环的时机:指针不为null或栈不为空

一个节点左孩子为空，说明当前节点是当前子树的中间节点，加入结果数组中，然后遍历右孩子。右孩子也为空，说明当前子树遍历完成，回退到上一层的父节点，并将其加入到结果数组。

回退之后遍历右孩子（左孩子之前已访问过），右孩子遍历方法和上面一样，先把右子树根节点入栈，先左遍历，再弹根节点即中间节点放入结果数组，回退到根节点再右遍历。右孩子遍历完之后继续回溯，此时就是父节点的父节点。

总结：当前节点不为空把节点入栈，访问左节点；当前节点为空弹栈顶元素，访问右节点。

### 统一写法

数据结构：

栈存放待处理的节点（处理是指放入结果数组以及查找其左右节点）

思路

循环条件：栈不为空继续遍历

出栈一个节点，然后把其子节点和它本身入栈，并使用一个null顶在中间节点上面，入栈顺序决定之后的遍历顺序

以先序遍历为例：

出栈一个节点此时是中间节点，会遇到null，就再出一次栈把中间节点放入res，然后直接continue进下一个循环，下一个循环栈中会弹出它的左节点，即左子树根节点，左节点此时作为中间节点优先被处理重复上述过程。

### 层序遍历

队列存放待处理节点

没处理完队列就不会为空

一层处理完出栈，放入它的下一层进队列
