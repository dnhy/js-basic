## 算法

1.通过策略跳过某些不需要的情况

双指针

2.模拟

3.换一种计算策略

前缀和

## KMP算法

核心原理：

匹配串和原串逐个字符比较，遇到匹配串不匹配的字符时，它前面的子串中的前后缀一致的部分可以用来减少比较次数

跳到前缀的后一个继续比较，因为此时匹配串中不匹配字符的前面这个子串中的后缀和原串中不匹配字符的前面几个已经确定是匹配的，由于匹配串的子串中的前缀后缀是一致的，那跳到的字符的前面的部分即前缀也肯定是和原串中不匹配字符的前面几个匹配的，所以可以略去前缀那几个字符的比较，直接从前缀的后一个开始和原串比较。

next数组创建：

j前缀末尾，i后缀末尾，j+1代表当前i之前（包含i）这个子串中，最长的和后缀字母相等的**前缀的长度**

next是记录匹配串中的每一个子串的最长相等前后缀

如果相等，next[i]的值就是j的值(下标值)+1,表示有几个前缀字母和后缀匹配了

如果不等，j进行回退（缩减匹配到的前缀长度），j回退到的坐标取决于next[j-1],其实就是递减，直到j回到0为止（while循环）。



如果相等之后j再往后移动一位，不相等时j不移动，i也往后移动一位（for循环），继续比较i之前（包含i）的子串中的前缀和后缀

此时j位置之前的部分已经在上一轮比较过了，从j当前的位置进行比较，如果相等，就是j上一轮的个数加1，就是j+1。

然后j和i再往后一位，进行循环。

## 滑动窗口最大值

1 3 -1 -3  5  3 2 1

queue

3 2 1

res

3 3 5 5 5 3

- 单调队列:单调减的队列

每次push，都把当前队列最后一个元素和它的前面的比这个新的val小的去除掉，大的不动，然后再push进去

每次pop，如果之前已经pop过了，就不pop，说明这个元素比新的元素小，不可能在队头。如果是没pop的元素，需要pop，说明这个元素之前是比队列后面的元素大的才能幸存到最后，那必然在队头，所以判断和队头相等就pop。

队列的第一个元素就是最大的元素

- 主调函数

先往队列加k个元素，然后往后移动窗口（移动时新增和删除队列元素，保证队列是递减的）。

## 二叉树

### 种类

- 满二叉树

- 完全二叉树

- 二叉搜索树

  节点有顺序的树

- 平衡二叉搜索树

  所有左子树和右子树的高度差距不能大于1

### 存储

数组、链表

### 遍历方式

深度优先、广度优先

- 深度优先搜索是前序中序后序

- 广度优先搜索是层序遍历

前序：中左右

中序：左中右

后序：左右中

使用递归、迭代实现

## 二叉树遍历

### 递归遍历

略

### 迭代遍历

#### 前序和后序

push的时机：遍历访问的顺序和处理的顺序是一致的，先访问根节点，就先处理根节点（处理是指放入结果数组以及遍历子节点）

数据结构：

使用栈，栈中总是存放**待处理节点**（处理是指放入结果数组以及查找其左右节点）

判断条件：未遍历完时，栈中总是有节点

思路：

放入一个根节点

进入循环

出一个节点，遍历该节点的下一层，每一层从右往左添加到栈中

出的节点会先作为结果放入结果数组，然后用栈继续遍历下一层，实现中左右

如何保证中优先：每次循环都把中放入，再通过栈遍历下一层

对于后续遍历：

前序遍历：中左右

后续遍历：左右中

后续遍历只需要把前序遍历的代码更换左右位置，变成中右左，然后翻转结果数组，变成左右中即可

#### 中序遍历

左中右

push的时机：遍历和处理的顺序是不一样的，先遍历的先不处理（处理是指放入结果数组以及遍历子节点）

数据结构：

栈中放入**待处理的节点**（处理是指放入结果数组以及查找其左右节点）

思路：

​		     5
​	      /      \
​	   4	 	 6
​    /      \
 1	      2

如何保证左优先：每次循环先把左孩子放入结果数组中

退出循环的时机:指针指到null且栈为空

进行循环的时机:指针不为null或栈不为空

一个节点左孩子为空，说明当前节点是当前子树的中间节点，加入结果数组中，然后遍历右孩子。右孩子也为空，说明当前子树遍历完成，回退到上一层的父节点，并将其加入到结果数组。

回退之后遍历右孩子（左孩子之前已访问过），右孩子遍历方法和上面一样，先把右子树根节点入栈，先左遍历，再弹根节点即中间节点放入结果数组，回退到根节点再右遍历。右孩子遍历完之后继续回溯，此时就是父节点的父节点。

总结：当前节点不为空把节点入栈，访问左节点；当前节点为空弹栈顶元素，访问右节点。

### 统一写法

数据结构：

栈存放待处理的节点（处理是指放入结果数组以及查找其左右节点）

思路

循环条件：栈不为空继续遍历

出栈一个节点，然后把其子节点和它本身入栈，并使用一个null顶在中间节点上面，入栈顺序决定之后的遍历顺序

以先序遍历为例：

出栈一个节点此时是中间节点，会遇到null，就再出一次栈把中间节点放入res，然后直接continue进下一个循环，下一个循环栈中会弹出它的左节点，即左子树根节点，左节点此时作为中间节点优先被处理重复上述过程。

### 层序遍历

队列存放待处理节点

没处理完队列就不会为空

一层处理完出栈，放入它的下一层进队列

事件复杂度较其他三种较高

## 对称二叉树

1.前序遍历优先比较中间节点

2.中间节点值一样的话递归比较下面的子树。下面的子树每一层节点使用对称比较，外面的节点两两比较，内部的节点两两比较

3.如果中间节点下面的子树每一层都一样、中间节点值也一样就表示中间节点为根节点的这两颗子树一样，层层返回结果。

## 二叉树的高度和深度

高度是从下往上，深度是从上往下

二叉树根节点的高度就是它的最大深度（根节点到叶子节点经过的最大节点数）

最小深度是根节点到叶子节点经过的最小节点数

求每层高度需要从叶子节点往上遍历，使用左右中即后序遍历

求每层深度需要从根节点往下遍历，使用中左右即前序遍历

## 求左叶子之和

```js
var sumOfLeftLeaves = function (root) {
    const sum = getLeft(root, 0);
    console.log(sum)
};

function getLeft(node, sum) {
    if (!node) return 0;

    let leftNodeSum = getLeft(node.left)//0
    let rightNodeSum = getLeft(node.right)//22

    // 如果该节点的左子树是左叶子节点，就把左叶子节点+右子树的结果返回
    if (node.left && !node.left.left && !node.left.right) return  rightNodeSum + node.left.val;

    //如果该节点的左子树不是左叶子节点，就把左右子树的结果返回 
    return leftNodeSum + rightNodeSum;

}
```

## 求叶子之和

```js
var sumOfLeftLeaves = function (root) {
    const sum = getLeft(root, 0);
    console.log(sum)
};

function getLeft(node, sum) {
    if (!node) return 0;

    let leftNodeSum = getLeft(node.left)//0
    let rightNodeSum = getLeft(node.right)//22

    let mid =leftNodeSum+rightNodeSum;
    if (node.left && !node.left.left && !node.left.right) mid+= node.left.val
    if (node.right && !node.right.left && !node.right.right) mid+= node.right.val

    return mid;
}
```

